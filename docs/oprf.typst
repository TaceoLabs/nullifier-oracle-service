#import "preamble.typst": *
#import "@preview/fletcher:0.5.8" as fletcher: diagram, edge, node
#import "@preview/frame-it:1.2.0": *
#import "@preview/dashy-todo:0.1.0": todo

#let inst_taceo = institute("TACEO", email: "office@taceo.io");

#let authors = (
  author("Daniel Kales", insts: inst_taceo),
  author("Roman Walch", insts: inst_taceo),
)

#let title = "A Nullifier Protocol based on a Verifiable, Threshold OPRF"
#let abstract = ""
#let keywords = ("OPRF", "VOPRF", "threshold", "ZKP")

#show: report.with(
  title: title,
  authors: authors,
  abstract: abstract,
  keywords: keywords,
)

// Custom commands

#let sk = $serif("sk")$;
#let pk = $italic("pk")$;
#let nonce = $italic("nonce")$;
#let uid = $italic("id")_italic("u")$;
#let rpid = $italic("id")_italic("rp")$;
#let action = $italic("action")$

// frames, needs to be after the report import, as something breaks that otherwise

#let (remark, implementation) = frames(
  remark: ("Remark",),
  implementation: ("Implementation Note",),
)
#show: frame-style(styles.hint)

#outline()


= Introduction

Semaphore @semaphorev4 is a zero-knowledge protocol that allows users to cast a message (e.g., a vote) as a provable member of a predetermined group, without revealing their actual identity. Internally it also produces a nullifier, which can be stored and is used to prevent users from casting a message twice (e.g., prevent double voting). The basic workflow of Semaphore is as follows: Users first create an identity (a private/public keypair) and add a so-called identity commitment to a public Merkle tree. These Merkle trees are usually managed on-chain and define the group members, as all identities committed to in the leaves of the Merkle tree are part of a group. Finally, to send a message, a user create a zero-knowledge proof that shows: (i) they hold the secret key for a given identity, (ii) the given identity is committed to in the Merkle tree corresponding to a given public root hash and (iii) the produced nullifier is computed correctly for the given message as $H(sk, "scope")$. Since the nullifier is enforced to be computed correctly in the ZK proof, it can be used to check that a given secret key is only used once for a given scope.

The Semaphore protocol is already in version 4 and audited implementations of the circuits and client SDK exist.#footnote[See https://docs.semaphore.pse.dev for more details.] However, for some especially long-running use-cases there exists some drawbacks as well: First, the standard Semaphore protocol equates a group member with a single identity. This lack of account abstraction makes multi-device support as well as recovery of group membership when losing a secret key difficult. Second, since the secret key of the identity is directly hashed as part of the nullifier, leakage of this secret key allows all entities to create nullifier hashes for any scopes. This obviously allows account takeover, but additionally also allows historical analysis of this accounts behavior, linking together nullifiers from different scopes.

In this document we propose a nullifier protocol that improves upon these aspects. First, as a minor change, the Merkle tree holding the accounts now has an additional layer that allows accounts to add a small number of identities in a single leaf, allowing for any of those identities to be used to create the nullifier. This introduces some problems, since now we can no longer use the secret key as part of the nullifier, since an account can now have multiple identities. To address this, we remove the secret key as part of the nullifier altogether, and use the index of the account in the Merkle tree instead. Just doing this naÃ¯vely breaks some privacy aspects of the nullifier, since now anyone could try to brute force the nullifier hash for some given index, and therefore trace actions of a specific account.

To add another secret back into the nullifier calculation, we employ an Oblivious Pseudorandom Function, where the client inputs the index into the OPRF protocol and the OPRF server holding a key $k$ returns $F_k (i)$, without learning $i$. In this setup, there is now a secret $k$ that is part of the nullifier calculation, however, it is known to the OPRF server, which could still perform the above attack. To address this, the OPRF key is secret-shared between a set of nodes, and a threshold OPRF protocol is executed instead. This protects against a malicious server, but we also need to enforce that clients cannot query arbitrary OPRF inputs, as this would allow them to calculate nullifiers of other accounts. To this end, the clients also proof in zero-knowledge that they know a secret key for a given identity in the leaf that is queried in the OPRF.

Finally, an important part of the original Semaphore protocol is the zero-knowledge proof attesting the correct calculation of the nullifier. We still require this property, but have to extend it with the correct calculation of the OPRF. Therefore, a verifiable variant of the OPRF is used, which allows the OPRF servers to prove the correct calculation of the OPRF against a known public key. This proof must then be verified in the zero-knowledge proof attesting the correct calculation of the nullifier.

== Notation
#todo(position: "inline")[Write]

= Background

== BabyJubJub

BabyJubJub is an elliptic curve designed for efficient operations inside zk-SNARKs that operate over the BN254 scalar field. The main efficiency aspect stem from the fact that the BN254 scalar field is the base field of BabyJubJub and therefore we can directly operate on the $(x,y)$ coordinate representation in the proof system without having to use foreign field arithmetic, which is notoriously expensive. BabyJubJub is defined in EIP-2494 @eip2494, and it should be noted that there are a few conflicting definitions floating around that use slightly different, isomorphic curves instead.

#implementation[On the `ark-ed-on-bn254` crate][At the time of writing, the `ark-ed-on-bn254` crate is one of these conflicting implementations, as its definition of the twisted Edwards curve is actually using the "Reduced Twisted Edwards" form from @eip2494 and is therefore incompatible, although cheap mapping functions do exist. That is why we created a new crate `ark-babyjubjub` that follows the definitions below.]

The definitions below follow the EIP-2494 proposal and are compatible with existing implementations in Circom. We repeat the definitions of the BabyJubJub curve below.

=== Definiton of BabyJubJub
Let
$ p = 21888242871839275222246405745257275088548364400416034343698204186575808495617 $ and $bb(F)_p$ be the finite field with $p$ elements. $p$ is the order of the scalar field of the elliptic curve BN254, a common pairing curve used in zk-SNARKs.

==== Twisted Edwards Form

Let $E$ be the twisted Edwards elliptic curve defined over $bb(F)_p$ described by the equation $ 168700x^2 + y^2 = 1 + 168696 x^2 y^2. $ $E$ is called BabyJubJub and has order $ n = 21888242871839275222246405745257275088614511777268538073601725287587578984328, $ which factors into $n = h dot q$, where the cofactor $h = 8$ and the prime $ q = 2736030358979909402780800718157159386076813972158567259200215660948447373041. $

The generator point $G$ of the elliptic curve is the point of order $n$ with $ G = (995203441582195749578291179787384436505546430278305826713579947235728471134,\ 5472060717959818805561601436314318772137091100104008585924551046643952123905). $
The base point $B$ is chosen to be $B = 8G$ and has order $q$. Let $ B = (5299619240641551281634865583518297030282874472190772894086521144482721001553, \
  16950150798460657717958625567821834550301663161624707787222815936182638968203). $

==== Montgomery Form

Let $E_M$ be the Montgomery elliptic curve defined over $bb(F)_p$ described by the equation $ v^2 = u^3 + 168698u^2 + u. $



$E_M$ is birationally equivalent to $E$, and the following mappings are used to convert points from one curve to the other.

$ E_M mapsto E: (u,v) -> (x,y) = (u/v, (u-1)/(u+1)) $
$ E mapsto E_M: (x,y) -> (u,v) = ((1+y)/(1-y), (1+y)/((1-y)x)) $


== EdDSA on BabyJubJub

One of the main use-cases of BabyJubJub is to build a digital signature scheme from it and verify the resulting signatures in a Groth16 proof. EdDSA is somewhat standardized in RFC 8032 @rfc8032, however, concrete details are only given for the specific curves Curve25519 and Curve448. Furthermore, the default internal hash functions such as SHA-512 are not zk-SNARK friendly. We instantiate an EdDSA variant using the BabyJubJub elliptic curve using Poseidon2 @GrassiKS23 the hash function used for the Fiat-Shamir transform in @alg:eddsa. We also refer to @ChalkiasGN20 for a rigorous treatment of EdDSA variants and follow their recommendations to achieve a strongly unforgable variant. The variant below is also "cofactored", meaning it is amenable to batch verification.

#show: style-algorithm
#algorithm-figure(
  "BabyJubJub/Poseidon EdDSA signature",
  stroke: black,
  {
    import algorithmic: *
    Function(
      "KeyGen",
      $$,
      {
        LineComment(Assign[$k$][${0,1}^256$], [Sample random $k$])
        LineComment(Assign[$(h_0,h_1,...,h_511)$][$serif("Blake3")(k)$], [Expand secret using hash function])
        LineComment(
          Assign[$s$][$2^251 + h_250 dot 2^250 + dots + h_3 dot 2^3$],
          [Compute secret scalar, with specific bits chosen],
        )
        LineComment(Assign[$pk$][$sk dot B$], [Compute the public key])
        Return[$sk, (h_256,...,h_511), pk$]
      },
    )
    LineBreak
    Function(
      "Sign",
      $M, sk, (h_256,...,h_511)$,
      {
        LineComment(Assign[$r$][$serif("Blake3")(h_256||...||h_511||M)$], [Generate a pseudorandom nonce])
        LineComment(Assign[$R$][$r dot B$], [Interpret $r$ as a scalar and obtain a curve point ])
        LineComment(Assign[$e$][$serif("Poseidon2")(R||pk||M)$], [Compute the challenge $e$])
        Assign[$s$][$r + e dot sk mod q$]
        Return[$R,s$]
      },
    )
    LineBreak
    Function(
      "Verify",
      $M, pk, sigma = (R,s)$,
      {
        LineComment(Line([Reject if $S in.not {0,..,q-1}$]), [Check for non-canonical $s$])
        Line([Reject if $A$ is one of the small-order points on $E$.])
        Line([Reject if $A$ or $R$ are non-canonical.])
        LineComment(Assign[$e$][$serif("Poseidon2")(R||pk||M)$], [Compute the challenge $e$])
        Line([Accept if $8(s dot B - R - e dot pk) = 0$])
      },
    )
  },
)  <alg:eddsa>


== TwoHashDH OPRF

In this paper we aim to build a distributed and verifiable OPRF service. Our main construction is derived from the TwoHashDH OPRF which was introduced in @JareckiL10. We give its basic construction is given in @fig:twohashdh, where $H(x)$ hashes the input field element onto an elliptic curve, instantiated with BabyJubJub in our case.

#figure(
  rect(table(
    columns: (2fr, 1fr, 2fr),
    stroke: none,
    table.header([Client($x$)], [], [Server($k$)]),
    table.hline(stroke: 0.05em),
    [$beta arrowrl bb(Z)_q$], [], [],
    [$A <- beta dot H(x)$], math.attach($arrow.r$, t: $A$), [$B <- k dot A$],
    [], math.attach($arrow.l$, t: $B$), [],
    [Output $H'(x, (beta^(-1) dot B))$],
  )),
  caption: [The TwoHashDH OPRF construction from @JareckiL10.],
  kind: "scheme",
  supplement: [Scheme],
)
<fig:twohashdh>

=== Hash To Curve

#todo(position: "inline")[Write]

== Discrete Logarithm Equality Proof

#todo(position: "inline")[Citation needed]

Adding verifiability to @fig:twohashdh can be done by adding a discrete logarithm equality proof. In the following we describe how on can proof that two group elements $A$ and $C$ share the same discrete logarithm $k$ for their respective bases $D$ and $B$. In other words, given $A, B, C, D in bb(G)$, we show that $A=k dot D$ and $C = k dot B$ for the same $x in bb(F)_q$. The following algorithm specifies $D$ as an arbitrary group element, in practice $D$ can simply be chosen as the generator of $bb(G)$.

#show: style-algorithm
#algorithm-figure(
  "Dicrete Logarithm Equality Proof",
  stroke: black,
  {
    import algorithmic: *
    Function(
      "Prove",
      $k, B, D$,
      {
        LineComment(Assign[$r$][$bb(F)_q$], [Sample random $r$])
        Assign[$R_1$][$r dot D$]
        Assign[$R_2$][$r dot B$]
        Assign[$e$][$H(k dot D,B, k dot B,D,R_1, R_2) in bb(F)_q$]
        Assign[$s$][$r + e dot k$]
        Return[$e,s$]
      },
    )
    LineBreak
    Function(
      "Verify",
      $A, B, C, D, e, s$,
      {
        LineComment(Line([Reject if $s in.not {0,..,q-1}$]), [Check for non-canonical $s$])
        If("not " + `validPoints` + $(A, B, C, D)$, { Return[$bot$] })
        If("not " + `nonZeroPoints` + $(A,B,C,D)$, { Return[$bot$] })
        Assign[$R_1$][$s dot D -e dot A$]
        Assign[$R_2$][$s dot H -e dot C$]
        If("not " + `nonZeroPoints` + $(R_1, R_2)$, { Return[$bot$] })
        Assign[$e'$][$H(A,B, C,D,R_1, R_2) in bb(F)_q$]
        Return[$e=e'$]
      },
    )
  },
)  <alg:prover>

= Our Construction

In this section we describe the full protocol between the client and multiple OPRF servers.

== Threshold OPRF

Translating @fig:twohashdh from a single-server OPRF to a threshold OPRF is trivial. Since the server (in the single server setting) only performs one group operation $B <- k dot A$ on a blinded $A$, $k$ can just be secret-shared (e.g., using additive or Shamir @Shamir79 secret-sharing) and the client reconstructs the response point $B$ from the shares. The protocol is given in @fig:twohashdh_mpc. Thereby, the properties of the used secret-sharing protocol (e.g., honest/dishonest majority, threshold, ect.) are inherited. For a discussion on threshold OPRFs in general we refer to @CasacubertaHL22.

#figure(
  rect(table(
    columns: (2fr, 1fr, 2fr),
    stroke: none,
    table.header([Client($x$)], [], [$n$ Server($[k]$)]),
    table.hline(stroke: 0.05em),
    [$beta arrowrl bb(Z)_q$], [], [],
    [$A <- beta dot H(x)$], math.attach($arrow.r$, t: $A$), [$[B] <- [k] dot A$],
    [], math.attach($arrow.l$, t: $[B]$), [],
    [$B <-$ `Reconstruct`$([B])$], [], [],
    [Output $H'(x, (beta^(-1) dot B))$],
  )),
  caption: [The distributed TwoHashDH OPRF construction derived from @fig:twohashdh.],
  kind: "scheme",
  supplement: [Scheme],
)
<fig:twohashdh_mpc>

== Distributed Discrete Logarithm Equality Proof

=== Additively Shared Discrete Logarithm Equality Proof

#todo(position: "inline")[adapt the text]
In this section we describe how to distribute @alg:prover to multiple provers, which each have an additive secret-share of the value $x$. To reduce communication complexity, we introduce an accumulator party which reconstructs public values and computes challenges. Thus, each prover only has to communicate with the accumulating party, which in practice can be the verifier.

#show: style-algorithm
#algorithm-figure(
  "Additively Shared Discrete Logarithm Equality Proof",
  stroke: black,
  {
    import algorithmic: *
    Comment([Each server $i$:])
    Function(
      "partial_commitments",
      $k_i, B, D$,
      {
        LineComment(Assign[$r_i$][$bb(F)_q$], [Sample random share $r_i$])
        Assign[$R_(i,1)$][$r_i dot D$]
        Assign[$R_(i,2)$][$r_i dot B$]
        Assign[$C_i$][$k_i dot B$]
        Return[$r_i, C_i, R_(i,1), R_(i,2)$]
      },
    )
    LineBreak
    Comment([The accumulator with input from all $n$ servers:])
    Function(
      "create_challenge",
      $A, B, D, (C_1, R_(1,1), R_(1,2)), dots, (C_n, R_(n,1), R_(n,2))$,
      {
        Assign[$R_1$][$R_(1,1) + dots + R_(n, 1)$]
        Assign[$R_2$][$R_(1,2) + dots + R_(n, 2)$]
        Assign[$C$][$C_1 + dots + C_n$]
        Assign[$e$][$H(A,B, C,D,R_1, R_2) in bb(F)_q$]
        Return[$e$]
      },
    )
    LineBreak
    Comment([Each server $i$ on input $e$ from the client:])
    Function(
      "challenge",
      $k_i, r_i, e$,
      {
        Assign[$s_i$][$r_i + e dot k_i$]
        Return[$s_i$]
      },
    )
    LineBreak
    Comment([The accumulator with input from all $n$ servers:])
    Function(
      "combine_proofs",
      $e, s_1, ..., s_n$,
      {
        Assign[$s$][$s_1 + dots + s_n$]
        Return[$e, s$]
      },
    )
  },
)  <alg:add_prover>

@alg:add_prover has two communication rounds between each server and the accumulator, but the servers do not need to communicate with any other server. Thereby, each random share of the server is protected by the discrete logarithm hardness assumption, preventing the accumulator from learning anything about the secrets $x, k$ and their shares.

In essence, @alg:add_prover rewrite the non-interactive prove back to its interactive version. Thus, the accumulator would not need to sample the random value $e$ via the Fiat-Shamir random oracle. However, keeping the same verifier as in the non-distributed version and keeping public verifiability (i.e., proving on chain it is not a simulated proof) requires the usage of the random oracle. Since the prover now does not chose the challenge via Fiat-Shamir itself, each server now should only respond once to a challenge for an existing random share $k_i$.

=== Shamir Shared Discrete Logarithm Equality Proof

#todo(position: "inline")[adapt the text]
In order to rewrite @alg:add_prover from additive to Shamir secret-sharing, we have to make the following changes. First, the share $x_i$ needs to be a valid Shamir share. Second, the random share $k_i$ also needs to be sampled as a valid Shamir shares, which introduces an additional communication round. Finally, the accumulator reconstructs the commitments $C, R_1, R_2$ and the proof $s$ using lagrange interpolation from a set of $d+1$ servers, where $d$ is the chosen degree of the underlying sharing polynomial.

#show: style-algorithm
#algorithm-figure(
  "Shamir Shared Discrete Logarithm Equality Proof",
  stroke: black,
  {
    import algorithmic: *
    Comment([Each server $i$:])
    Function(
      "partial_commitments",
      $k_i, B, D$,
      {
        LineComment(Assign[$r_i$][`Shamir.Rand()`], [Sample random Shamir share $r_i$])
        Assign[$R_(i,1)$][$r_i dot D$]
        Assign[$R_(i,2)$][$r_i dot B$]
        Assign[$C_i$][$k_i dot B$]
        Return[$r_i, C_i, R_(i,1), R_(i,2)$]
      },
    )
    LineBreak
    Comment([The accumulator with input from $t = d+1$ out of $n$ servers:])
    Function(
      "create_challenge",
      $A, B, D, (C_1, R_(1,1), R_(1,2)), dots, (C_t, R_(t,1), R_(t,2))$,
      {
        Assign[$R_1$][$lambda_1 dot R_(1,1) + dots + lambda_t dot R_(t, 1)$]
        Assign[$R_2$][$lambda_1 dot R_(1,2) + dots + lambda_t dot R_(t, 2)$]
        Assign[$C$][$lambda_1 dot C_1 + dots + lambda_t dot C_t$]
        Assign[$e$][$H(A,B, C,D,R_1, R_2) in bb(F)_q$]
        Return[$e$]
      },
    )
    LineBreak
    Comment([Each server $i$ on input $e$ from the client:])
    Function(
      "challenge",
      $k_i, r_i, e$,
      {
        Assign[$s_i$][$r_i + e dot k_i$]
        Return[$s_i$]
      },
    )
    LineBreak
    Comment([The accumulator with input from $t = d+1$ out of $n$ servers:])
    Function(
      "combine_proofs",
      $e, s_1, ..., s_t$,
      {
        Assign[$s$][$lambda_1 dot s_1 + dots + lambda_t dot s_t$]
        Return[$e, s$]
      },
    )
  },
)  <alg:shamir_prover>

The presence of $k_i arrow.l$ `Shamir.Rand()` in @alg:shamir_prover has the implication, that the servers now need to be able to communicate with each other in order to be able to create valid Shamir shares. In practices one can think of either generating this random share directly on request, or precomputing random values $k$ in an offline phase and consuming them in the online phase. Another solution can be to let the accumulator chose the $d+1$ servers in the beginning of the protocol and only use their shares in the whole computation. In this setting, the chosen parties can simply sample their shares at random without communication, since the requirement that all $n$ shares need to be on the same polynomial is not there anymore.

== Full Distributed OPRF-Based Nullifier Protocol

We give the full verifiable OPRF based distributed nullifier service construction in @fig:full_protocol. For the description of the zero knowledge proofs $pi_1$ and $pi_2$ we refer to @sec:ZK.

#figure(
  rect(table(
    columns: (2fr, 1fr, 2fr),
    stroke: none,
    table.header([Client($sk, pk, uid, rpid, action, K$)], [], [$n$ Server($k_i, K = k dot B$)]),
    table.hline(stroke: 0.05em),
    [$beta arrowrl bb(Z)_q$], [], [],
    [$q <- H_1(uid, rpid, action)$], [], [],
    [$sigma <-$`Sign`$(sk, q)$], [], [],
    [$A <- beta dot H_2(q)$], [], [],
    [$pi_1 <-$ `prove`$(sigma, A,$ `valid`$(pk))$],
    math.attach($arrow.r$, t: $A, pi_1, action, rpid$),
    [if `verify`$(pi_1, A, action, rpid) = bot$ then abort],
    [], [], [$(r_i, C_i, R_(i,1), R_(i,2)) <-$ `dlog.partial_commitments`$(k_i, A, B)$],
    [$C <-$ `Reconstruct`$([C])$], math.attach($arrow.l$, t: $[C], [R_1], [R_2]$), [],
    [$R_1 <-$ `Reconstruct`$([R_1])$], [], [],
    [$R_2 <-$ `Reconstruct`$([R_2])$], [], [],
    [$e <- H_3(K, A, C, B,R_1, R_2) in bb(F)_p$], math.attach($arrow.r$, t: $e$), [$s_i <- r_i + e dot k_i$],
    [], math.attach($arrow.l$, t: $[s]$), [],
    [$s <-$ `Reconstruct`$([s])$], [], [],
    [$n <- H_4(q, (beta^(-1) dot C))$], [], [],
    [$pi_2 <-$ `prove`$(sigma, A,$`valid`$(pk),$ `dlog.verify`$(e,s), n)$], [], [],
    [Output $(n, pi_2)$],
  )),
  caption: [The distributed verifiable TwoHashDH based nullifier construction derived from @fig:twohashdh.],
  kind: "scheme",
  supplement: [Scheme],
)
<fig:full_protocol>

=== Clients Zero Knowledge Proofs <sec:ZK>

We describe the ZK proofs $pi_1$ and $pi_2$ from @fig:full_protocol in this section.

==== Query Proof $pi_1$

The goal of the query proof $pi_1$ is to convince the server that a client is authorized to send a request. Therefore, `valid`$(pk)$ is a core part of this zero knowledge which shows that the used public key $pk$ is in some kind of allowlist. To prove knowledge of the corresponding private key $sk$ we opt to verify a signature $sigma <-$`Sign`$(sk, q)$ of the actual query $q$ inside the ZK proof. We use this signature to not have $sk$ as a private witness in the ZK proof. This has the advantage that a client can securely outsource proof generation to, e.g., an MPC-based prover network without having to secret-share its key $sk$ with them, minimizing damage in case of a privacy breach.

Finally, $pi_1$ binds everything together by proving the correct calculation of the query point $A$ from its part.

In more details, proof $pi_1$ consists of the following statements:
#figure(
  box(stroke: black, inset: 1em)[
    #align(left)[
      *Proof $pi_1 <-$ `prove`$(sigma, A,$ `valid`$(pk))$:*
      1. The query $q$ is computed as the hash $q <- H_1(uid, rpid, action)$ where we use Poseidon2 for $H_1$ due to its ZK friendliness.
      2. The signature $sigma$ is a valid EdDSA signature of $q$ using some key $sk$. This is by proving the EdDSA verifier inside the ZK proof, such that $sk$ is not part of the witness.
      3. The public key $pk$ used to verify the signature $sigma$ is part of an allowlist. Concretely, this allowlist is currently implemented as a Merkle tree accumulator with the root node $m$ and a list of $t$ public keys at each leaf. Proving this statement is done by showing:
        - The hash of the $t$ public keys is the actual leaf $pk'$ of a Merkle tree
        - The prover knows a path from $pk'$ to the root node $m$. This path consists of the sibling nodes in each level of the tree, as well as the position of the leaf which is $uid$.
        - $pk$ used for verifying the signature is at index $i$ in the list of all $t$ public keys.
      4. Finally, the derivation of the query point $A$ is computed correctly by proving $A<-beta dot H_2(q)$ where $H_2(q)$ hashes $q$ onto the BabyJubJub curve and $beta$ is a blinding element.
    ]],
  caption: [The statements proven in $pi_1$.],
)<fig:pi1>

The following elements need to be public inputs to $pi_1$:
- $rpid$ needs to be a public input, such that the OPRF servers know which secret $k$ (which belongs to the specified RP) they need to use in their response.
- $action$ is currently public to bind the nullifier to a specific action publicly. If this is undesired, $action$ can also be made private with no downside since $action$ is part of the nullifier computation and can thus not be requested a second time.
- The Merkle root $m$ is a public input to bind the validity check of $pk$ to a known allowlist.
- The query point $A$ is public such that the OPRF servers can verify the requests by the client.

==== Nullifier Proof $pi_2$

The role of $pi_2$ is having a proof of the full nullifier construction. Thus, it needs to prove the following statements:
#figure(
  box(stroke: black, inset: 1em)[
    #align(left)[
      *Proof $pi_2 <-$ `prove`$(sigma, A,$`valid`$(pk),$ `dlog.verify`$(e,s), n)$:*
      1. All 4 statements of the query proof $pi_1$ from @fig:pi1 are proven.
      2. The discrete logarithm equality proof from the OPRF servers is verified to show that the servers computed the response honestly. This is done by evaluating the verifier from @alg:prover inside the ZK proof, similar to proving the correct EdDSA signature.
      3. The OPRF result is unblinded and hashed to get the OPRF output $n = H_4(q, beta^(-1)dot C)$. To avoid inverting $beta$ in the BabyJubJub scalarfield $bb(F)_q$ inside a ZK proof over a different prime field $bb(F)_p$ (the BabyJubJub basefield) we prove the unblinding step via injecting the result $C'= beta^(-1)dot C$, showing it is a valid BabyJubJub point and proving $C=beta dot C'$.
      4. We allow a message $serif("msg") in bb(F)_p$ to be part of the proof. To disallow tampering of the proof, we add a constraint squaring the message (as is also done in a standard Semaphore proof).
    ]],
  caption: [The statements proven in $pi_2$.],
)<fig:pi2>


The following elements need to be public inputs to $pi_2$:
- $rpid$ needs to be a public input, such that everyone can verify that the nullifier was computed for a specific RP.
- $action$ is currently public to bind the nullifier to a specific action publicly. If this is undesired, $action$ can also be made private with no downside since $action$ is part of the nullifier computation and can thus not be requested a second time.
- The OPRF public key $K = k dot B$ to show that the correct key $k$ was used in the OPRF calculation.
- The Merkle root $m$ is a public input to bind the validity check of $pk$ to a known allowlist.
- The message $serif("msg")$ which is also part of the proof.
- The final nullifier $n$ is public to bind the nullifier to the proof.

=== Key Generation and Reshare

#todo(position: "inline")[Write a discussion and mention the stuff in the appendix there.]

= Evaluation

== ZK Proofs: Circom

#todo(position: "inline")[Correct the numbers]

In @tab:circom_constraints, we give the R1CS constraint count for various building blocks of the ZK proof.

#figure(
  table(
    columns: 3,
    align: (left, right, left),
    stroke: none,
    table.header([Function], [Constraint Cost], [Comment]),
    table.hline(stroke: 0.05em),
    [BabyJubJubScalarMulAny], [2310], [$P s$ for arbitrary $P$, 254 bit $s$.],
    [BabyJubJubScalarMulFix], [512], [$P s$, for fixed, public $P$, 254 bit $s$.],
    [Poseidon2 (t=3)], [240], [Poseidon2 with statesize 3.],
    [Poseidon2 (t=4)], [264], [Poseidon2 with statesize 4.],
    [BabyJubJubPoseidonEdDSAVerify], [4217], [EdDSA Verification on BabyJubJub, using Poseidon as a Hash.],
    [encode_to_curve], [808], [Encoding an arbitrary field element into a random BabyJubJub Curve point.],
    [DLogEqVerify], [10296], [Verification of a discrete logarithm equality proof over BabyJubJub.],
    [BinaryMerkleTree (d=32)], [7875], [Binary Merkle Tree using Poseidon with state size 2, depth 32.],
    [Semaphore (d=32)], [9383], [Sempahore proof with MT depth 32.],
  ),
  caption: [Constraint cost for various Circom ZK building blocks.],
) <tab:circom_constraints>

=== OPRF client query validity proof
#todo(position: "inline")[Just write we implemented it in circom and it takes n constraints]

// For the OPRF protocol, the client needs to proof the validity of the following statements:
// 1. I know a secret key $sk$ for a given public key $pk$.
//   - This statement is proven by providing a signature of a nonce under the given secret key $sk$. This signature is then verified in the ZK proof.
//   - $serif("Verify")(pk, sigma, nonce) == 1$
// 2. The public key $pk$ is at the leaf with index $uid$ in the Merkle tree corresponding to the root hash $h$.
//   - This statement is proven by providing $uid$, the Merkle tree path neighbors $h_i$ and recomputing the path up to the root.
//   - $serif("MTPathVerify")(pk, h_i, h)$
// 3. The OPrf query $q$ is derived as specified from $uid$ as $H(uid)^beta$, for a random, but known $beta$.
//   - This statement is proven by recalculating the hash function $H$ which hashes a field element to the BabyJubJub curve, followed by a scalar multiplication with $beta$.
//   - $serif("ECScalarMul")(serif("encode_to_curve")(uid), beta) = q$

The approximate circuit size for these statements is: $4217 + 7875 + 808 + 2310 = 15210 < 2^14$.

=== Nullifier Validity Proof

#todo(position: "inline")[Just write we implemented it in circom and it takes n constraints]

// After the OPRF protocol has been executed, the client computes the nullifier $ell = H(rpuid, action, epoch, rpid)$. It then proofs the validity of the whole derivation of the nullifier. This includes the steps 1-3 from above, as well as:
// 4. The OPRF result returned from the servers is correct w.r.t. their OPRF public key.
//   - This is handled using a discrete logarithm equality proof to show that $log_g (g^k) = log_q (q^k)$
//   - $serif("DLogEqVerify")(g,g^k, q, z = q^k, s, e) == 1$
// 5. The OPRF result is unblinded and hashed to get the OPRF output $rpuid = H'(uid, z^(beta^(-1)))$.
//   - This would normally require inverting $beta$, which is expensive since it is not native to the proof system scalar field. However, we can utilize a common trick in ZKPs and inject the result $y = z^beta^(-1)$ and show that $y^beta = z$ instead, which saves the calculation of the inverse.
//   - $serif("Hash2")(uid, y) == rpuid$ and $serif("ECScalarMul")(y, beta) == z$
// 6. The Nullifier is calculated correctly:
//   - $serif("Nullifier")(rpuid, action,epoch, rpid)$

The approximate circuit size for these statements is: $15210 + 10296 + 240 + 2310 + 264 = 28320 < 2^15.$


= Conclusion


#bibliography("references.bib")


#appendices(
  [
    = Random sampling

    Let
    $ p = 21888242871839275222246405745257275088548364400416034343698204186575808495617 $
    be the order of the BN254 curve.
    Let
    $ q = 2736030358979909402780800718157159386076813972158567259200215660948447373041 $
    be the order of the prime-order subgroup of the BabyJubJub curve.

    #theorem(
      [Given a uniform random element $x in bb(F)_p$, the distributions $x mod q$ and $x arrowrl bb(F)_q$ are statistically indistinguishable.],
    )
    #v(-1cm)
    #proof(
      [Let $r = 8q$, then $r approx p + 2^(125.637)$. The distributions $x arrowrl bb(Z)_p$ and $y arrowrl bb(Z)_r$ are distinguishable only if the drawn element is from the gap of the two ranges, i.e. from the interval \[p, r\). This event happens with probability $(r-p)/r approx 2^(125.637)/r approx 1/2^(127.96)$, which is negligible, meaning our two distributions are statistically indistinguishable. For the second part of the proof, observe that $r$ is an exact multiple of $q$ by design. This means that the distributions $x arrowrl bb(Z)_q; "return" x$ and $y arrowrl bb(Z)_r; "return" y mod q$ are indistinguishable, since $bb(Z)_q$ is a subgroup of $bb(Z)_r.$ Putting the two facts together concludes the proof.],
    )

    == Shamir Key Generation and Resharing

    In this section we describe how to generate the Shamir-shared OPRF key and how to reshare it with a potentially new set of key holders. The reshare protocol can also be used to refresh the shares of the OPRF key by resharing to the same set of computing nodes. We begin by describing the maliciously secure distributed key generation with identifiable abort which allows to securely generate a fresh Shamir secret with any threshold of corrupted parties $t < n$.

    === Pedersen's Protocol with Proof of Possession (PedPoP) @CritesKM21
    The PedPoP protocol is an adaption of the protocol introduced in @KomloG20. It is basically a parallel instantiation of verifiable secret-sharing (VSS) based on Shamir secret-sharing with the addition of vector commitments and Schnorr proofs to ensure that communicated shares are consistent and that unforgeability holds even if more than half of the parties are corrupted. Furthermore, the protocol allows to detect and disqualify malicious parties during the key generation protocol. We depict the protocol in @scheme:pedpop.


    #figure(
      box(stroke: black, inset: 1em)[
        #align(left)[
          - *Round1*:
            1. Each party $P_i$ chooses a random polynomial $f_i (Z)$ over $bb(F)_p$ of degree $t$ $ f_i(Z) = a_(i,0) + a_(i,1) Z + dots + a_(i,t) Z^t $ and computes $A_(i,k) = G^(a_(i,k))$ for $k in[t]$. Denote $x_i= a_(i,0)$ and $X_i = A_(i,0)$. Each $P_i$ computes a proof of possession of $X_i$ as a Schnorr signature as follows. They sample $r_i arrowrl bb(F)_p$ and set $R_i arrow.l G^(r_i)$. They set $c_i arrow.l H(R_i, X_i)$ and set $z_i arrow.l r_i + c_i dot x_i$. They then derive a commitment $arrow(C)_i = (A_(i,0), dots, A_(i, t-1))$ and broadcast $((R_i, z_i), arrow(C)_i)$.
            2. After receiving the commitment from all other parties, each participant verifies the Schnorr signature by computing $c'_j arrow.l H(R_j, A_(j, 0))$ and checking that $ R_j A_(j,0)^(c'_j) = G^(z_j). $ If any checks fail, they disqualify the corresponding participant; otherwise, they continue to the next step.
          - *Round2*:
            3. Each $P_i$ computes secret-shares $x_(i,j) = f_i (serif(id)_j)$ for $j = 1, dots, n$, where $serif(id)_j$ is the participant identifier, and sends $x_(i,j)$ secretly to party $P_j$.
            4. Each party $P_j$ verifies the shares they received from the other parties by checking that
            $ G^(x_(i,j)) = product_(k=0)^(t)A_(i,k)^(serif(id)_j^k) $ If the check fails for an index $i$, then $P_j$ broadcasts a complaint against $P_i$.
          - *Round3*:
            5. For each of the complaining parties $P_j$ against $P_i$, $P_i$ broadcasts the share $x_(i,j)$. If any of the revealed shares fails to satisfy the equation, or should $P_i$ not broadcast anything for a complaining player, then $P_i$ is disqualified. The share of a disqualified party $P_i$ is set to $0$.
          - *Output*:
            6. The secret-share for each $P_j$ is $s_j = sum_(i=1)^n x_(i,j)$.
            7 If $X_i=X_j$ for any $i != j$, then abort. Else, the output is the joint public key $serif(pk)=product_(i=1)^n X_i$.
        ]],
      caption: [The PedPoP key generation protocol @CritesKM21.],
    )<scheme:pedpop>

    === PedPoP Reshare Protocol

    After the pair $[serif(sk)], serif(pk)$ is generated, one can use a combined version of the reshare algorithm from @ChoudhuriGGJK21 and the PedPoP protocol @CritesKM21 to reshare the key $[serif(sk)]$ to a new set of parties, while also maintaining its correctness, privacy, and the possibility to identify malicious parties. While the original PedPoP key generation protocol requires 3 communication rounds (2 rounds for the computation plus an extra round for blaming malicious parties), our PedPoP reshare protocol only requires 2 rounds. During key generation, performing the two computation rounds in parallel would allow malicious parties to potentially introduce a bias into the random key. Since during resharing the key is already fixed, one does not need to protect against this attack vector and can perform the two communication rounds in parallel. We depict our resharing protocol in @scheme:pedpop_reshare.

    #figure(
      box(stroke: black, inset: 1em)[
        #align(left)[
          - *Round1*:
            1. To reshare the share $x_i$ each party $P_i$ chooses a random polynomial $f_i (Z)$ over $bb(F)_p$ $ f_i (Z) = x_i + a_(i,1) Z + dots + a_(i,t) Z^t $ and computes $A_(i, k) = G^(a_(i, k))$ for $k in[t]$. Denote $X_i = A_(i, 0) = G^(x_i)$. Each $P_i$ computes a proof of possession of $X_i$ as a Schnorr signature as follows. They sample $r_i arrowrl bb(F)_p$ and set $R_i arrow.l G^(r_i)$. They set $c_i arrow.l H(R_i, X_i)$ and set $z_i arrow.l r_i + c_i dot x_i$. They then derive a commitment $arrow(C)_i = (A_(i, 0), dots, A_(i, t-1))$ and broadcast $((R_i, z_i), arrow(C)_i)$ to the new set of parties.
            2. After receiving the commitment from all old parties, each participant of the new set of parties verifies the Schnorr signature by computing $c'_j arrow.l H(R_j, A_(j, 0))$ and checking that $ R_j A_(j,0)^(c'_j) = G^(z_j). $ Verify, that $A_(j,0)$ is equal to the commitment one receives by interpolating the commitments from Step 4 from the previous reshare round (in the exponent). If any checks fail, they accuse the corresponding participant and remove its contribution; otherwise, they continue to the next step.
          - *Round2* (In parallel to Round 1):
            3. Each $P_i$ of the old set of parties computes secret-shares $x_(i,j) = f_i (serif(id)_j)$ for $j = 1, dots, n$, where $serif(id)_j$ is the participant identifier, and sends $x_(i,j)$ secretly to party $P_j$ of the new set.
            4. Each party $P_j$ of the new set verifies the shares they received from the old parties:
              $ G^(x_(i,j)) = product_(k=0)^(t)A_(i,k)^(serif(id)_j^k) $
              If the check fails for an index $i$, then $P_j$ broadcasts a complaint against $P_i$ from the old set.
          - *Round3*:
            5. For each of the complaining parties $P_j$ against $P_i$, $P_i$ broadcasts the share $x_(i,j)$. If any of the revealed shares fails to satisfy the equation, or should $P_i$ not broadcast anything for a complaining player, then $P_i$ is disqualified. The share of a disqualified party $P_i$ is ignored.
          - *Output*:
            6. The secret-share for each $P_j$ is $s_j = sum_(i=1)^n x_(i,j)lambda_i$, whre $lambda_i$ is the corresponding lagrange coefficient.
            7. Check, whether the output $product_(i=1)^n X_i^(lambda_i)$ is equal to the public key $serif(pk)$. This should always happen if there are at most $t$ cheating parties
        ]],
      caption: [The PedPoP reshare protocol.],
    )<scheme:pedpop_reshare>

    === Proposal 1

    Based on @scheme:pedpop we design a blockchain-assisted key generation protocol that does not require the parties to have direct communication channels with each other. However, knowledge of their public keys is requried.

    #figure(
      box(stroke: black, inset: 1em)[
        #align(left)[
          - *Round1*:
            1. Each party $P_i$ chooses a random polynomial $f_i (Z)$ over $bb(F)_p$ of degree $t$ $ f_i(Z) = a_(i,0) + a_(i,1) Z + dots + a_(i,t) Z^t $ and computes $A_(i,k) = G^(a_(i,k))$ for $k in[t]$. Denote $x_i= a_(i,0)$ and $X_i = A_(i,0)$. Each $P_i$ computes a proof of possession of $X_i$ as a Schnorr signature as follows. They sample $r_i arrowrl bb(F)_p$ and set $R_i arrow.l G^(r_i)$. They set $c_i arrow.l H(R_i, X_i)$ and set $z_i arrow.l r_i + c_i dot x_i$. They then derive a commitment $arrow(C)_i = (A_(i,0), dots, A_(i, t-1))$ and posts $((R_i, z_i), arrow(C)_i)$ on chain.
            2. The smart contract verifies the Schnorr signature by computing $c'_j arrow.l H(R_j, A_(j, 0))$ and checking that $ R_j A_(j,0)^(c'_j) = G^(z_j). $ If no error was found, the smart contract stores the commitments $arrow(C)$.
          - *Round2*:
            3. Each $P_i$ computes secret-shares $x_(i,j) = f_i (serif(id)_j)$ for $j = 1, dots, n$, where $serif(id)_j$ is the participant identifier, and posts an encryption of $x_(i,j)$ using $P_j$'s public key on chain.
            4. Each party $P_j$ reads the shares from the other parties from the chain by checking that
            $ G^(x_(i,j)) = product_(k=0)^(t)A_(i,k)^(serif(id)_j^k) $  If the check fails for an index $i$, then $P_j$ posts a complaint against $P_i$ on chain.
          - *Round3*:
            5. Each party has a predefined amount of time to post complaints on chain. For each of the complaining parties $P_j$ against $P_i$, $P_i$ broadcasts the share $x_(i,j)$. If any of the revealed shares fails to satisfy the equation, or should $P_i$ not broadcast anything for a complaining player, then $P_i$ is slashed and the protocol aborts.
          - *Output*:
            6. The secret-share for each $P_j$ is $s_j = sum_(i=1)^n x_(i,j)$.
            7. The smart contract checks if $X_i=X_j$ for any $i != j$ in which case it aborts. Otherwise, it computes the public key from the commitments $serif(pk)=product_(i=1)^n X_i$.
        ]],
      caption: [Proposal 1 for key generation based on PedPoP @CritesKM21.],
    )<scheme:proposal1>

    @scheme:proposal1 has the following (undesired) property: If party $P_j$ files a complaint against $P_i$ (round 3) the share $(x_(i,j))$ is leaked. To prevent this, one can build the complaint round differently. If $P_j$ makes a complaint against $P_i$, then $P_i$ has to post a ZK proof that the share was derived correctly (using the commitments to the polynomials on chain) and that the encryption of the share on chain matches the correctly derived share. If that is the case, $P_j$ filed a wrong complaint and is slashed. Otherwise, or if $P_i$ fails to provide a proof in time, $P_i$ is slashed. The cost of the ZK proof is $t + 1$ BabyJubJubScalarMulFix for checking the commitments, two BabyJubJubScalarMulAny for deriving a secret key for encryption, and a Poseidon based encryption. Thus, the cost of this ZK proof is approximately $5500 + t dot 512$ #todo[Correct the numbers] constraints, which is less than $2^14$ for $t=15$.
    To allow this complained proof to be generic for thresholds which might change later on, the circuit can be modified to an upper bound of $t'$, and have the concrete $t$ as a public input. This requires to Cmux each random coeeficient with 0 in case its index is greater $t$ and recomputing $t'$ commitments using BabyJubJubScalarMulFix. Furthermore, it could make sense to accumulate the commitments using Poseidon2 to reduce the number of public inputs.

    For reshare, we modify @scheme:pedpop_reshare similar as for @scheme:proposal1, with the additional constraint that the commitments to the new shares have to produce the same public key. This should come implicitly since the smart contract has to check that the correct share was used by interpolating the commitments in the exponent anyways (step 2 in @scheme:pedpop_reshare).

    Furthermore, for both the key generation and reshare, the proof of possession (i.e., the Schnorr proof in Step 1) is not strictly required and can be skipped.

    Proposal 1 has the advantage that it is very simple and easy to compute and does not require a direct network channel between the computing parties. Furthermore, it is publicly verifiable that the parties keep the same secret during a reshare procedure. However, the public can not verify that all parties behaved correctly without one of the parties posting a complaint on chain.

    === Proposal 2


    #todo(position: "inline")[Correct the numbers]

    The second proposal aims to achieve full verifiability with ZK proofs on chain. While the ZK proofs are more expensive compared to Proposal 1, they get rid of the complaint round and smart contracts only accept values if a ZK proof of correctness was provided.

    #figure(
      box(stroke: black, inset: 1em)[
        #align(left)[
          - *Round1*:
            1. Each party $P_i$ chooses a random polynomial $f_i (Z)$ over $bb(F)_p$ of degree $t$ $ f_i(Z) = a_(i,0) + a_(i,1) Z + dots + a_(i,t) Z^t, $ computes $X_i = G^(a_(i,0))$ and $c = H(a_(i,1), dots, a_(i, t))$, and posts $X_i$ and $c$ on chain.
          - *Round2*:
            2. Each $P_i$ computes secret-shares $x_(i,j) = f_i (serif(id)_j)$ for $j = 1, dots, n$, where $serif(id)_j$ is the participant identifier, and posts a commitment $H(x_(i,j))$ and an encryption of $x_(i,j)$ using $P_j$'s public key on chain, alongside a ZK proof verifying correctness.
            3. The smart contract verifies the ZK proof and accepts the encryptions of the shares if the proof is correct.
            4. Each party $P_j$ reads the shares from the other parties from the chain.
          - *Output*:
            6. The secret-share for each $P_j$ is $s_j = sum_(i=1)^n x_(i,j)$.
            7. The smart contract checks if $X_i=X_j$ for any $i != j$ in which case it aborts. Otherwise, it computes the public key from the commitments $serif(pk)=product_(i=1)^n X_i$.
        ]],
      caption: [Proposal 2 for key generation using ZK proofs.],
    )<scheme:proposal2>

    For reshare, we also have to proof that the correct share was used using the commitment $H(x_(i,j))$ from the previous round. When computing everything into one ZK proof (per party), the proof consists of the following:
    - Recomputing the commitments:
      - Poseidon2 commitment for $t$ inputs
      - $n$ Poseidon2 commitments for the shares
      - A BabyJubJubScalarMulFix for the commitment $X_i$
      - For reshare: $n$ additional Poseidon2 commitments to verify the previous round
    - For the Encryption:
      - $2 dot n$ BabyJubJubScalarMulAny for deriving the secret keys
      - $n$ Poseidon2 hashes for the encryption
    - In total:
      - $3 dot n + t$ Poseidon2 with 240 constraints each
      - 1 BabyJubJubScalarMulFix with 512 constraints
      - $2 dot n$ BabyJubJubScalarMulAny with 2310 constraints

    This totals to approximately 165000 ($<2^18$) constraints for $n=30$ with $t=15$, where the majority with 140k constraints comes from the BabyJubJubScalarMulAny gadget.

    Alternatively, one can think of producing $n$ proofs for the $n$ derived shares instead of proving everything in one large proof.
  ],
)
